use std::path::Path;
use std::process::Command;
use futures_util::TryFutureExt;
use tokio::fs;
use crate::models::entity::file::File;
use crate::dao::{CityDao, FileDao};
use crate::pool::app_state::DbPool;
use crate::models::entity::city::NewCity;
use crate::schema::models::svg_id;

pub(crate) struct FileManager;

impl FileManager {
   async fn receive_file( user_id: &str, path: &str, size: i64, pool: &DbPool,file_type:&str) -> Result<(), String> {
    // Create a new File instance
    let new_file = File {
        file_id: 0, // This will be auto-generated by the database
        user_id: Some(user_id.parse().map_err(|_| "Invalid user_id")?),
        path: Some(path.to_string()),
        file_type: Some(file_type.to_string()), // You can set the appropriate file type
        size: Some(size),
        created_at: Some(chrono::Utc::now().naive_utc()),
        updated_at: Some(chrono::Utc::now().naive_utc()),
        permissions: Some("default".to_string()), // Set default permissions
    };

    // Save the new_file to the database using FileDao
    FileDao::create_file(pool, &new_file).map_err(|e| format!("Failed to insert file: {:?}", e))?;

    Ok(())
}

    async fn receive_image(city_id: &str, file_content: &[u8], user_id: i32, image_name: &str, session_id: &str) -> Result<(), String> {
    use chrono::Utc;
    let timestamp = Utc::now().timestamp();
    let new_file_name = format!("{}_{}_{}.png", timestamp, session_id, image_name);
    let base_path = format!("data/{}/{}/images/", user_id, city_id);
    let file_path = Path::new(&base_path).join("images").join(new_file_name);
        fs::write(file_path, file_content).await.map_err(|e| format!("Failed to save file: {:?}", e))?;



    Ok(())
}

    fn receive_svg(city_id:&str, file: &File) -> Result<(), String> {
        Ok(())
    }

    fn receive_click_position(city_id:&str, file: &File,image_id:i32,svg_id: svg_id) -> Result<(), String> {


        Ok(())
    }

    pub(crate) async fn new_city_and_new_directory(pool:&DbPool,user_id:&i32,city_name:&str) -> Result<(), String> {
        let user_id_clone = user_id.to_string();
        let pool_clone = pool.clone();
        let city_name = city_name.to_string();
         let (city_id, city_root_path) = tokio::task::spawn_blocking(move || {
             CityDao::create_city_with_model_path(&pool_clone, &NewCity {
                 user_id: Some(user_id_clone.parse().map_err(|_| "Invalid user_id")?),
                 city_name: city_name.to_string(),
             }).map_err(|_| "Failed to create city")
         }).await.map_err(|_| "Task join error")??;
        //创建相关的目录 images,svgs,obj_models,city_models
        let base_path = format!("data/{}/{}", user_id, city_id);
        let directories = ["images", "svgs", "obj_models", "city_models","click_positions","videos"];
        for dir in &directories {
            let dir_path = Path::new(&base_path).join(dir);
            fs::create_dir_all(&dir_path).await.map_err(|e| format!("Failed to create directory: {:?}, error: {:?}", dir_path, e))?;
        }

        Ok(())
    }

    pub fn convert_video_to_h264_aac(input_path: &str, output_path: &str) -> Result<(), String> {
        let status = Command::new("ffmpeg")
            .arg("-i")
            .arg(input_path)
            .arg("-c:v")
            .arg("libx264")
            .arg("-c:a")
            .arg("aac")
            .arg(output_path)
            .status()
            .map_err(|e| format!("Failed to execute ffmpeg: {:?}", e))?;

        if status.success() {
            Ok(())
        } else {
            Err(format!("ffmpeg exited with status: {:?}", status.code()))
        }
    }

}