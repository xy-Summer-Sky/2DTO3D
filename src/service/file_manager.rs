use crate::dao::{CityDao, FileDao};
use crate::models::entity::city::NewCity;
use crate::models::entity::file::File;
use crate::pool::app_state::DbPool;
use crate::schema::models::svg_id;
// use crate::utils::convert_to_h264_aac;
use chrono::Utc;
use futures_util::TryFutureExt;
use std::path::Path;
use clap::builder::TypedValueParser;
use tokio::fs;
use crate::models::entity::image::Image;
use crate::models::request_models_dto::VideoUpload;

pub(crate) struct FileManager;

impl FileManager {
    async fn receive_file(
        user_id: &str,
        path: &str,
        size: i64,
        pool: &DbPool,
        file_type: &str,
    ) -> Result<(), String> {
        // Create a new File instance
        let new_file = File {
            file_id: 0, // This will be auto-generated by the database
            user_id: Some(user_id.parse().map_err(|_| "Invalid user_id")?),
            path: Some(path.to_string()),
            file_type: Some(file_type.to_string()), // You can set the appropriate file type
            size: Some(size),
            created_at: Some(chrono::Utc::now().naive_utc()),
            updated_at: Some(chrono::Utc::now().naive_utc()),
            permissions: Some("default".to_string()), // Set default permissions
        };

        // Save the new_file to the database using FileDao
        FileDao::create_file(pool, &new_file)
            .map_err(|e| format!("Failed to insert file: {:?}", e))?;

        Ok(())
    }

    async fn receive_image(
        city_id: i32,
        file_content: &[u8],
        user_id: i32,
        image_name: &str,
        session_id: &str,
        pool: &DbPool,
    )  -> Result<(i32, i32, i32), String> {

        //保存到目录中
        use chrono::Utc;
        let timestamp = Utc::now().timestamp();
        let new_file_name = format!("{}_{}_{}.png", timestamp, session_id, image_name);
        let base_path = format!("data/{}/{}/images/", user_id, city_id);
        let file_path = Path::new(&base_path).join("images").join(new_file_name);
        fs::write(file_path, file_content)
            .await
            .map_err(|e| format!("Failed to save file: {:?}", e))?;
        
        //将图片记录生成到数据库中
        let new_image = crate::models::entity::image::NewImage {
            image_path: Some(file_path.to_string_lossy().to_string()),
            user_id: Some(user_id),
            city_id: Some(city_id),
        };

        let image_id = crate::dao::ImageDao::create_image_and_get_id(pool, &new_image)
            .await
            .map_err(|e| format!("Failed to insert image: {:?}", e))?;
        
        //图片做为文件保存插入到数据库中
        Self::receive_file(
            &user_id.to_string(),
            &file_path.to_string_lossy(),
            file_content.len() as i64,
            pool,
            "image",
        ).await.expect("TODO: panic message");

        //将用户id、图片id和城市id关联起来，做为返回值
        // 将用户id、图片id和城市id关联起来，作为返回值
        Ok((user_id, image_id, city_id))
    }

    fn receive_svg(city_id: &str, file: &File) -> Result<(), String> {
        Ok(())
    }

    fn receive_click_position(
        city_id: &str,
        file: &File,
        image_id: i32,
        svg_id: svg_id,
    ) -> Result<(), String> {
        Ok(())
    }

    pub(crate) async fn new_city_and_new_directory(
        pool: &DbPool,
        user_id: &i32,
        city_name: &str,
    ) -> Result<(), String> {
        let user_id_clone = user_id.to_string();
        let pool_clone = pool.clone();
        let city_name = city_name.to_string();
        let (city_id, city_root_path) = tokio::task::spawn_blocking(move || {
            CityDao::create_city_with_model_path(
                &pool_clone,
                &NewCity {
                    user_id: Some(user_id_clone.parse().map_err(|_| "Invalid user_id")?),
                    city_name: city_name.to_string(),
                },
            )
                .map_err(|_| "Failed to create city")
        })
            .await
            .map_err(|_| "Task join error")??;
        //创建相关的目录 images,svgs,obj_models,city_models
        let base_path = format!("data/{}/{}", user_id, city_id);
        let directories = [
            "images",
            "svgs",
            "obj_models",
            "city_models",
            "click_positions",
            "videos",
        ];
        for dir in &directories {
            let dir_path = Path::new(&base_path).join(dir);
            fs::create_dir_all(&dir_path).await.map_err(|e| {
                format!("Failed to create directory: {:?}, error: {:?}", dir_path, e)
            })?;
        }

        Ok(())
    }


}
